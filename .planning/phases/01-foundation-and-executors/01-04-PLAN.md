---
phase: 01-foundation-and-executors
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - Makefile
  - internal/executor/find.go
  - internal/executor/find_test.go
  - internal/executor/npm_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "m2cv version prints real version info when built with make"
    - "TestFindNodeExecutable_NotFound passes when no system npm exists"
    - "TestNPMExecutor_NotFound passes when no system npm exists"
  artifacts:
    - path: "Makefile"
      provides: "Build targets with ldflags for version injection"
      contains: "ldflags"
    - path: "internal/executor/find.go"
      provides: "FindNodeExecutable with injectable fallback paths"
      exports: ["FindNodeExecutable", "FindNodeExecutableWithFallbacks"]
  key_links:
    - from: "Makefile"
      to: "cmd/root.go"
      via: "ldflags setting version/commit/date vars"
      pattern: "-X.*cmd\\.version"
---

<objective>
Fix two UAT gaps: (1) version command shows placeholder values, (2) executor tests fail due to system path leakage.

Purpose: These are regressions from Phase 1 that prevent clean test runs and proper version identification.
Output: Working Makefile for versioned builds, isolated executor tests that pass regardless of host environment.
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-and-executors/01-03-SUMMARY.md
@cmd/root.go
@internal/executor/find.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Makefile with ldflags for version injection</name>
  <files>Makefile</files>
  <action>
Create `Makefile` at project root with the following targets:

1. **Variables at top:**
   ```makefile
   BINARY_NAME := m2cv
   VERSION := $(shell git describe --tags --always --dirty 2>/dev/null || echo "dev")
   COMMIT := $(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
   DATE := $(shell date -u +"%Y-%m-%dT%H:%M:%SZ")
   LDFLAGS := -ldflags "-X github.com/richq/m2cv/cmd.version=$(VERSION) -X github.com/richq/m2cv/cmd.commit=$(COMMIT) -X github.com/richq/m2cv/cmd.date=$(DATE)"
   ```

2. **Targets:**
   - `build`: `go build $(LDFLAGS) -o $(BINARY_NAME) .`
   - `install`: `go install $(LDFLAGS) .`
   - `test`: `go test ./... -v`
   - `clean`: `rm -f $(BINARY_NAME)`
   - `all`: depends on clean, build (default target)

3. **Mark .PHONY for all targets**

The key fix: The ldflags pass `-X` flags to set `cmd.version`, `cmd.commit`, and `cmd.date` at link time, overriding the hardcoded placeholder values in cmd/root.go.
  </action>
  <verify>
Run `make build` - builds successfully.
Run `./m2cv version` - shows git-derived version (not "dev"), commit hash (not "unknown"), and build date (not "unknown").
  </verify>
  <done>Version command displays real version info from git when built via `make build`.</done>
</task>

<task type="auto">
  <name>Task 2: Fix executor test isolation with injectable fallback paths</name>
  <files>internal/executor/find.go, internal/executor/find_test.go, internal/executor/npm_test.go</files>
  <action>
The root cause: `FindNodeExecutable` unconditionally checks `/usr/local/bin` and `/opt/homebrew/bin` (lines 50-53), so even when tests set `PATH=""`, `os.Stat` finds real system executables.

**Fix in `internal/executor/find.go`:**

1. Add a new function `FindNodeExecutableWithOptions` that accepts an optional config:
   ```go
   type FindOptions struct {
       // SkipSystemPaths disables checking /usr/local/bin and /opt/homebrew/bin
       SkipSystemPaths bool
   }

   func FindNodeExecutableWithOptions(name string, opts *FindOptions) (string, error) {
       // ... existing logic but conditionally skip system paths if opts.SkipSystemPaths
   }
   ```

2. Update `FindNodeExecutable` to call `FindNodeExecutableWithOptions(name, nil)` for backward compatibility.

3. In the candidate building section (around lines 49-53), wrap the system paths addition in a conditional:
   ```go
   if opts == nil || !opts.SkipSystemPaths {
       candidates = append(candidates,
           filepath.Join("/usr/local/bin", name),
           filepath.Join("/opt/homebrew/bin", name),
       )
   }
   ```

**Fix in `internal/executor/find_test.go`:**

Update `TestFindNodeExecutable_NotFound` (around line 106) to use the new function:
```go
_, err := FindNodeExecutableWithOptions("npm", &FindOptions{SkipSystemPaths: true})
```

This ensures the test only checks PATH (which is empty) and home-based paths (which point to empty tmpHome), not leaking to real system binaries.

**Fix in `internal/executor/npm_test.go`:**

Update `TestNPMExecutor_NotFound` (around line 264). The issue is that `NewNPMExecutor()` internally calls `FindNodeExecutable`. Two options:

Option A (preferred): Add a test-only constructor or option:
```go
// In npm.go, add:
func NewNPMExecutorWithFindOptions(findOpts *FindOptions, opts ...NPMOption) (*NPMExecutor, error)
```

Option B: Mock at the test level by also setting empty system paths. Since we control HOME, and PATH is empty, we need to ensure system paths are skipped.

Implement Option A for cleaner test isolation:
1. In `internal/executor/npm.go`, add `WithFindOptions(opts *FindOptions)` as an NPMOption
2. In `NewNPMExecutor`, if no explicit npm path given and FindOptions provided, use `FindNodeExecutableWithOptions`
3. Update `TestNPMExecutor_NotFound` to use `NewNPMExecutor(WithFindOptions(&FindOptions{SkipSystemPaths: true}))`

Alternative simpler fix: If `npm.go` doesn't need modification, the test can directly test `FindNodeExecutableWithOptions` instead, since that's what's actually being verified.
  </action>
  <verify>
Run `go test ./internal/executor/... -v -run NotFound` - both NotFound tests pass.
Run `go test ./internal/executor/... -v` - all executor tests pass.
Run `go test ./...` - all project tests pass.
  </verify>
  <done>TestFindNodeExecutable_NotFound and TestNPMExecutor_NotFound pass regardless of what executables exist on the host system.</done>
</task>

</tasks>

<verification>
1. `make build` - builds binary with version info
2. `./m2cv version` - shows real version (git tag or commit), commit hash, build date
3. `go test ./internal/executor/... -v -run NotFound` - both NotFound tests pass
4. `go test ./...` - all tests pass
5. `make test` - runs all tests successfully
</verification>

<success_criteria>
- `m2cv version` shows git-derived version info, not placeholder values
- TestFindNodeExecutable_NotFound passes in any environment
- TestNPMExecutor_NotFound passes in any environment
- All existing tests continue to pass
- Makefile provides standard build/test/clean targets
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-executors/01-04-SUMMARY.md`
</output>
