---
phase: 04-content-tailoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/optimize.go
  - cmd/root.go
autonomous: true

must_haves:
  truths:
    - "User can run m2cv optimize <app-name> and receive a tailored CV"
    - "Base CV is read from path specified in m2cv.yml"
    - "Job description is found in the application folder"
    - "Claude receives prompt with CV and job description content"
    - "ATS mode uses different prompt template when --ats flag provided"
    - "Model can be overridden with -m flag"
    - "Output is written to versioned file (optimized-cv-N.md)"
  artifacts:
    - path: "cmd/optimize.go"
      provides: "Optimize command implementation"
      exports: ["newOptimizeCommand"]
      min_lines: 80
  key_links:
    - from: "cmd/optimize.go"
      to: "internal/config/config.go"
      via: "FindWithOverrides + Load"
      pattern: "config\\.FindWithOverrides|configRepo\\.Load"
    - from: "cmd/optimize.go"
      to: "internal/application/versioning.go"
      via: "NextVersionPath for output"
      pattern: "application\\.NextVersionPath"
    - from: "cmd/optimize.go"
      to: "internal/executor/claude.go"
      via: "ClaudeExecutor.Execute with prompt"
      pattern: "exec\\.Execute"
    - from: "cmd/optimize.go"
      to: "internal/assets/assets.go"
      via: "GetPrompt for template"
      pattern: "assets\\.GetPrompt"
---

<objective>
Implement the `m2cv optimize` command that tailors a CV to a job description using Claude AI.

Purpose: This is the core AI feature of m2cv - taking a base CV and job description, calling Claude to produce a tailored version optimized for that specific role. Supports standard and ATS-optimized modes.

Output: Working `m2cv optimize <app-name>` command with --ats and -m flags, writing versioned output files.
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-content-tailoring/04-RESEARCH.md

# Existing patterns to follow
@cmd/apply.go
@internal/application/versioning.go
@internal/executor/claude.go
@internal/extractor/folder_name.go
@internal/config/config.go
@internal/assets/assets.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create optimize command</name>
  <files>cmd/optimize.go</files>
  <action>
Create `cmd/optimize.go` following the pattern from `cmd/apply.go`:

1. **Command structure:**
   - Use: `optimize <application-name>`
   - Short: "Tailor CV to job description with AI"
   - Args: cobra.ExactArgs(1)
   - Flags: `-m, --model` (string, override Claude model), `--ats` (bool, ATS optimization mode)

2. **runOptimize function flow:**

   a. **Validate application folder exists:**
      ```go
      appDir := filepath.Join("applications", applicationName)
      if _, err := os.Stat(appDir); os.IsNotExist(err) {
          return fmt.Errorf("application folder not found: %s. Run 'm2cv apply' first", appDir)
      }
      ```

   b. **Load config (required for base CV path):**
      - Use `config.FindWithOverrides(cfgFile, ".")` where cfgFile is the persistent flag from root.go
      - Load config with `config.NewRepository().Load(configPath)`
      - Error clearly if m2cv.yml not found: "m2cv.yml not found: %w. Run 'm2cv init' first"

   c. **Resolve and read base CV:**
      - Get baseCVPath from config.BaseCVPath
      - If baseCVPath flag (persistent from root) is non-empty, use that instead
      - Resolve relative paths against config directory: `filepath.Join(configDir, baseCVPath)`
      - Read with os.ReadFile, error with path in message if fails

   d. **Find and read job description:**
      - Use filepath.Glob to find *.txt files in appDir
      - Error if no .txt files found: "no .txt file found in %s. Job description required"
      - Read first match with os.ReadFile

   e. **Select and build prompt:**
      - If atsMode: use assets.GetPrompt("optimize-ats")
      - Else: use assets.GetPrompt("optimize")
      - Use strings.ReplaceAll for {{.BaseCV}} and {{.JobDescription}} placeholders

   f. **Determine model:**
      - Start with config.DefaultModel
      - If -m flag provided and non-empty, use that instead

   g. **Execute Claude:**
      - Create executor.NewClaudeExecutor()
      - Build opts slice: if model non-empty, append executor.WithModel(model)
      - Call exec.Execute(ctx, prompt, opts...)
      - Pass cmd.Context() for cancellation support

   h. **Write versioned output:**
      - Get output path with application.NextVersionPath(appDir)
      - Write result with os.WriteFile(..., 0644)
      - Print success: "Optimized CV written to: %s\n"

3. **Imports needed:**
   - context, fmt, os, path/filepath, strings
   - github.com/richq/m2cv/internal/application
   - github.com/richq/m2cv/internal/assets
   - github.com/richq/m2cv/internal/config
   - github.com/richq/m2cv/internal/executor
   - github.com/spf13/cobra

**Important:** Access cfgFile and baseCVPath persistent flags from root.go (they're package-level vars).
  </action>
  <verify>
Run `go build ./...` - should compile without errors.
Run `go vet ./cmd/...` - no issues.
  </verify>
  <done>
cmd/optimize.go exists with newOptimizeCommand function that:
- Has correct Use, Short, Args
- Has --model/-m and --ats flags
- runOptimize validates app folder, loads config, reads files, builds prompt, calls Claude, writes versioned output
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire optimize command to root</name>
  <files>cmd/root.go</files>
  <action>
Update `cmd/root.go` to register the optimize command:

1. In the `Execute()` function, add after the existing AddCommand calls:
   ```go
   rootCmd.AddCommand(newOptimizeCommand())
   ```

This follows the existing pattern where init and apply are added.
  </action>
  <verify>
Run `go build ./...` - compiles.
Run `./m2cv --help` - shows optimize in command list.
Run `./m2cv optimize --help` - shows optimize usage with -m and --ats flags.
  </verify>
  <done>
m2cv optimize command is registered and visible in help output.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` passes
2. `go vet ./...` passes
3. `./m2cv --help` lists optimize command
4. `./m2cv optimize --help` shows:
   - Usage: m2cv optimize <application-name>
   - Flags: -m, --model, --ats
</verification>

<success_criteria>
- cmd/optimize.go exists with complete implementation
- optimize command registered in root.go
- Build and vet pass
- Help output shows optimize with correct flags
</success_criteria>

<output>
After completion, create `.planning/phases/04-content-tailoring/04-01-SUMMARY.md`
</output>
