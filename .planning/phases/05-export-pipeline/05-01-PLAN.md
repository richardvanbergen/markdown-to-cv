---
phase: 05-export-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/generator/extractor.go
  - internal/generator/extractor_test.go
  - internal/generator/validator.go
  - internal/generator/validator_test.go
  - internal/generator/exporter.go
  - internal/generator/exporter_test.go
autonomous: true

must_haves:
  truths:
    - "JSON is reliably extracted from Claude output with markdown fences"
    - "JSON Resume documents validate against embedded schema before export"
    - "PDF export invokes resumed with correct theme and working directory"
  artifacts:
    - path: "internal/generator/extractor.go"
      provides: "ExtractJSON function for Claude output"
      exports: ["ExtractJSON"]
    - path: "internal/generator/validator.go"
      provides: "JSON Resume schema validation"
      exports: ["Validator", "NewValidator", "Validate"]
    - path: "internal/generator/exporter.go"
      provides: "PDF export via resumed"
      exports: ["Exporter", "NewExporter", "ExportPDF"]
  key_links:
    - from: "internal/generator/validator.go"
      to: "internal/assets/schema/resume.schema.json"
      via: "assets.GetSchema"
      pattern: "assets\\.GetSchema"
    - from: "internal/generator/exporter.go"
      to: "npx resumed"
      via: "exec.CommandContext"
      pattern: "exec\\.CommandContext.*npx"
---

<objective>
Build the generator service layer: JSON extraction from Claude output, JSON Resume schema validation, and PDF export via resumed.

Purpose: These three components form the core pipeline for the generate command. Each addresses a critical technical challenge identified in research: LLM output parsing, schema validation before export, and proper resumed invocation.

Output: Three production files with comprehensive tests covering edge cases identified in research (markdown fences, validation errors, theme resolution).
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-export-pipeline/05-RESEARCH.md

# Existing patterns to follow
@internal/assets/assets.go (GetSchema pattern)
@internal/executor/claude.go (executor interface pattern)
@internal/executor/npm.go (FindNodeExecutable pattern)
@internal/extractor/folder_name.go (extractor pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: JSON Extractor for Claude Output</name>
  <files>internal/generator/extractor.go, internal/generator/extractor_test.go</files>
  <action>
Create internal/generator/extractor.go with:
- ExtractJSON(claudeOutput []byte) (json.RawMessage, error)
- stripMarkdownFences(data []byte) []byte helper

Pattern from research (Pattern 1):
1. Strip markdown code fences using regex: `(?s)\`\`\`(?:json)?\n?(.*?)\n?\`\`\``
2. Find JSON object boundaries: first '{' to last '}'
3. Validate extracted content with json.Unmarshal

Error cases to handle:
- No JSON found (return descriptive error with snippet of input)
- Invalid JSON after extraction (return extraction attempt + parse error)
- Empty input (return error)

Create internal/generator/extractor_test.go with table-driven tests:
- Clean JSON object
- JSON wrapped in markdown fences
- JSON with explanatory text before/after
- Mixed text + fences
- No JSON content (error case)
- Invalid JSON syntax (error case)
- Multiple JSON objects (first valid one wins)
  </action>
  <verify>go test -v ./internal/generator/... -run TestExtract</verify>
  <done>ExtractJSON handles Claude output variations: clean JSON, markdown fences, explanatory text, and returns clear errors for invalid input</done>
</task>

<task type="auto">
  <name>Task 2: JSON Resume Schema Validator</name>
  <files>internal/generator/validator.go, internal/generator/validator_test.go</files>
  <action>
Add dependency: go get github.com/santhosh-tekuri/jsonschema/v6

Create internal/generator/validator.go with:
- Validator struct holding compiled *jsonschema.Schema
- NewValidator() (*Validator, error) - loads and compiles embedded schema
- Validate(resumeJSON []byte) error - validates document against schema

Pattern from research (Pattern 2):
1. Load schema via assets.GetSchema("resume.schema.json")
2. Unmarshal schema to interface{}
3. Create compiler, add resource, compile
4. Validate by unmarshaling JSON doc, calling schema.Validate

Error handling:
- Schema load failure (should not happen if assets work)
- Schema compilation failure (schema is invalid)
- Document parse failure (input is not valid JSON)
- Validation failure (return jsonschema error details)

Create internal/generator/validator_test.go with:
- Valid minimal JSON Resume (basics only)
- Valid full JSON Resume (basics + work + education)
- Missing required fields (should pass - JSON Resume has few required fields)
- Invalid field types (e.g., email as number)
- Completely invalid JSON (error case)
- Empty object (valid - JSON Resume is permissive)
  </action>
  <verify>go test -v ./internal/generator/... -run TestValidator</verify>
  <done>Validator compiles embedded JSON Resume schema and validates documents, returning clear error messages for invalid documents</done>
</task>

<task type="auto">
  <name>Task 3: PDF Exporter via resumed</name>
  <files>internal/generator/exporter.go, internal/generator/exporter_test.go</files>
  <action>
Create internal/generator/exporter.go with:
- Exporter struct holding npxPath string
- NewExporter() (*Exporter, error) - finds npx using executor.FindNodeExecutable
- ExportPDF(ctx context.Context, jsonPath, outputPath, theme, projectDir string) error
- CheckThemeInstalled(projectDir, theme string) error helper

Pattern from research (Pattern 3):
1. Check theme installed: stat projectDir/node_modules/jsonresume-theme-{theme}
2. Build command: npx resumed export {jsonPath} --output {outputPath} --theme jsonresume-theme-{theme}
3. Set cmd.Dir = projectDir (critical for node_modules resolution)
4. Use bytes.Buffer for stdout/stderr capture
5. Use cmd.Start() + cmd.Wait() (not cmd.Run())

Error handling:
- npx not found (from FindNodeExecutable)
- Theme not installed (clear message with install command)
- resumed execution failure (include stderr in error)

Create internal/generator/exporter_test.go with:
- Test NewExporter finds npx (skip if npx not available)
- Test CheckThemeInstalled with temp dir
- Test ExportPDF is harder without resumed - use integration test pattern:
  - Skip if resumed not installed
  - Create temp project with node_modules mock
  - Test command construction (can use mock or verify args)
  </action>
  <verify>go test -v ./internal/generator/... -run TestExporter</verify>
  <done>Exporter locates npx, checks theme installation, and invokes resumed with correct working directory and arguments</done>
</task>

</tasks>

<verification>
All generator components work:

```bash
# Run all generator tests
go test -v ./internal/generator/...

# Verify no unused imports or lint errors
go vet ./internal/generator/...
```
</verification>

<success_criteria>
1. ExtractJSON handles all Claude output variations from research
2. Validator compiles schema on first use and validates documents
3. Exporter finds npx and constructs correct resumed command
4. All tests pass with clear skip messages when dependencies unavailable
5. Error messages include actionable information (install commands, snippets)
</success_criteria>

<output>
After completion, create `.planning/phases/05-export-pipeline/05-01-SUMMARY.md`
</output>
